<p>Благодаря интенсивному развитию вычислительной техники моделирование приобретает общенаучный характер и применяется в исследованиях объектов и процессов, происходящих в природе, в науках о человеке и обществе.</p>
<p>Одним из наиболее важных применений моделей в практическом, и в историческом аспектах является прогнозирование поведения моделируемых объектов.</p>
<p>Моделирование применяется сегодня в самых различных областях: экологии и геофизике (анализ распространения загрязняющих веществ в атмосфере), транспорте (конструирование транспортных средств, полетные имитаторы для тренировки пилотов), электронике и электротехнике (эмуляция работы электронных устройств), экономике и финансах (прогнозирование цен на финансовых рынках), архитектуре и строительстве (исследование поведения зданий, конструкций и деталей под механической нагрузкой), управлении и бизнесе (моделирование рынков сбыта и рынков сырья), промышленности (моделирование роботов и автоматических манипуляторов), медицине и биологии (моделирование пандемий и эпидемий), политике и военном деле (моделирование развития межгосударственных отношений, моделирование театра военных действий).</p>
<p>Применение моделей позволяет проводить контролируемые эксперименты в тех ситуациях, где экспериментирование на реальных объектах было бы практически невозможным или экономически нецелесообразным. <span class="citation">[@Shennon]</span> В таких случаях может быть построена модель, на которой необходимые эксперименты могут быть проведены с относительной легкостью и недорого.</p>
<p>Выделяют три основных вида моделирования: аналитическое, численное и имитационное <span class="citation">[@disksobmod]</span>. В данной работе речь пойдет о имитационном моделировании. Имитационное моделирование — моделирование, при котором моделирующий алгоритм с той или иной степень точности воспроизводит функционирование исходной системы. Имитационная модель воспроизводит поведение моделируемой системы во времени. Имитационная модель может быть выполнена на распределенной вычислительной системе, где выигрыш по времени выполнения модели достигается за счет параллельного выполнения событий, запланированных на разные моменты модельного времени.</p>
<p>Существует несколько технологий на уровне архитектур, которые позволяют задать основные правила создания распределенных имитационных моделей: DDS, ARIS, HLA и др.</p>
<p>HLA (High-level architecture) — архитектура высокого уровня, представляет собой архитектуру общего назначения для распределенных компьютерных имитационных систем. Является стандартом IEEE 1516. В соответствии с правилами построения имитационных моделей по архитектуре HLA были реализованы, например, такие проекты как объединение центров управления космическими аппаратами в рамках программы МКС в единую распределенную систему (РКК Энергия/Королев — ATVCC/Тулуза — NASA JSC/Хьюстон); предшественник HLA — сеть SIMNET реально использовалась для тренировок и поддержки военных операций (а также их последующего анализа), например, в 1992 году в рамках кампании &lt;&lt;Буря в пустыне&gt;&gt;; 333-й Центр боевой подготовки сухопутных войск в п.Мулино и др.</p>
<p>В имитационном моделировании принято различать три понятия времени: физическое, модельное, процессорное <span class="citation">[@okol]</span>. Сущностью имитационного моделирования является продвижение модельного времени при выполнении модели и выполнение событий, связанных с определенными значениями модельного времени. В распределенной модели первичной единицей является логический процесс. Каждый логический процесс выполняется в своем модельном времени как самостоятельная последовательная модель. Логический процесс взаимодействует с другими процессами, передавая им сообщения. При распределенной реализации модельное время в разных логических процессах движется с разными скоростями и в некоторый произвольный момент времени оказывается разным.</p>
<p>Проиллюстрируем сказанное на примере исторического события — битвы при Ватерлоо.</p>
<div class="figure">
<embed src="графика/waterloo.pdf" />
<p class="caption">Корректная временная диаграмма исполнения модели</p>
</div>
<p>Наполеон Бонапарт (процесс <span class="math inline"><em>N</em></span>) должен был вступить в бой с герцогом Веллингтоном (процесс <span class="math inline"><em>W</em></span>), расположившемся со своей английской армией на пути к Брюсселю. Но оба полководца ждали подкрепления: герцог Веллингтон — прусского князя Блюхера (процесс <span class="math inline"><em>B</em></span>), Наполеон — своего маршала Груши (процесс <span class="math inline"><em>G</em></span>). И Наполеон и Веллингтон отправили командующим своими подкреплениями сообщения с категорическим требованием скорейшего прибытия под Ватерлоо для усиления основной группировки войск. Тем временем, армия Бонапарта в ожидании прибытия подкрепления маршала Груши начала атаку неприятеля. Веллингтону ничего не оставалось, как принять бой. Не смотря на более выгодное расположение войск Веллингтона и примерно равные силы с Наполеоном, французы развивали успешное наступление на англичан и едва не опрокинули их — положение Веллингтона становилось критическим. И только вовремя подоспевшее подкрепление князя Блюхера помогло герцогу сдержать натиск Наполеона, а затем и перейти в контрнаступление на французов. После чего, так и не дождавшийся своего маршала с подкреплением, французский император был разбит.</p>
<p>Предположим, что эти процессы выполняются на распределенной системе. И логический процесс <span class="math inline"><em>B</em></span> в силу определенных причин (например, резко возросла нагрузка на процессор) выполняется медленнее. Следовательно возникли задержки. Для логического процесса <span class="math inline"><em>W</em></span> получение сообщения в момент времени <span class="math inline"><em>t</em>5</span> означает изменение прошлого в момент времени <span class="math inline"><em>t</em>4</span>, что нарушает корректную последовательность развития моделирования.</p>
<div class="figure">
<embed src="графика/unwaterloo.pdf" />
<p class="caption">Некорректная временная диаграмма исполнения модели</p>
</div>
<p>Для того, чтобы модель правильно воспроизводила последовательность событий в моделируемой системе, необходимо чтобы не возникало подобных парадоксов времени. Тот процесс продвигает свое время вперед, который получил сообщение от процесса с большим временем. Если процесс получает сообщение от процесса с меньшим временем, т.е. <span class="math inline"><em>t</em><sub><em>i</em></sub><sup><em>m</em></sup> &lt; <em>t</em><sub><em>i</em></sub><sup><em>n</em></sup>,  <em>m</em> → <em>n</em></span>, получаем парадокс, т.е. говорят, что процесс приславший сообщение <span>“из прошлого”</span> отстает во времени <span class="citation">[@okol]</span>.</p>
<p>Для того, чтобы парадоксов времени в системе не возникало, необходимо предусмотреть специальные программы, которые бы синхронизировали по времени процессы в моделируемой системе. Такие программы получили название алгоритмов синхронизации модельного времени. Алгоритмы синхронизации разнообразны, но все их как правило можно разделить на два основных класса: консервативные и оптимистические.</p>
<p>Если синхронизация модельного времени процессов происходит под управлением консервативного алгоритма, это предполагает, что процесс получает сообщения в том же порядке, в котором их посылает ему отправитель. Иначе, консервативные алгоритмы блокируют продвижение модельного времени в том случае, если процесс получил сообщение от процесса с меньшим временем.</p>
<p>Оптимистические алгоритмы в аналогичном случае осуществляют откат времени процесса с большим временем до времени процесса, приславшего сообщение, обрабатывает его, а так же заново обрабатывают все сообщения от этого времени до текущего в правильной временной последовательности.</p>
<p>Математическая модель консервативного алгоритма синхронизации может быть представлена в виде <span class="citation">[@voz-disser]</span>: <br /><span class="math display">$$\label{eq:АС с синхронизацией взаимодействий}
\left\{
\begin{aligned}
x_{i+1}^n &amp; = x_i^n + \xi_i^n F^n(i)\\
F^n(i) &amp; = \begin{cases}
 1, &amp; \text{если $\forall m \in M^n : x_i^n + \xi_i^n \leqslant x_i^m + \xi_i^m$} \\
 0, &amp; \text{иначе}
 \end{cases}\\
x_0^n &amp; = 0\\
n &amp; = \overline{1, N}
\end{aligned}
\right.$$</span><br /> где <span class="math inline"><em>x</em><sub><em>i</em> + 1</sub><sup><em>n</em></sup></span> — время процесса <span class="math inline"><em>n</em></span> на следующем шаге, <span class="math inline"><em>ξ</em><sub><em>i</em></sub><sup><em>n</em></sup></span> — локальное приращение времени процесса <span class="math inline"><em>n</em></span> (время, затрачиваемое процессом на внутреннюю работу), <span class="math inline"><em>n</em></span> — процесс, который продвигает время (получает сообщение от процесса <span class="math inline"><em>m</em></span>), <span class="math inline"><em>m</em></span> — процесс, посылающий сообщение процессу <span class="math inline"><em>n</em></span>. Поскольку общее модельное время <span class="math inline"><em>T</em><sub><em>I</em></sub></span> — случайная величина, будем искать ее математическое ожидание. Модельное время всей системы на <span class="math inline"><em>i</em></span>-ом шаге равно минимальному времени процесса на этом шаге: <span class="math inline">∀ <em>i</em> : <em>M</em>(<em>T</em><sub><em>i</em></sub>)=<em>M</em>(<em>x</em><sub><em>i</em></sub>)</span>. С учетом оценки математических ожиданий величин <span class="math inline">{<em>x</em><sub><em>i</em></sub><sup><em>n</em></sup>}</span>, получаем: <br /><span class="math display">$$\label{eq:АС с синхронизацией взаимодействий}
K^n(i)=
\left\{
\begin{aligned}
\overline{M}(x_{i+1}^n) &amp; = \overline{M}(x_i^n) + M(\xi_i^n) \overline{F^n}(i)\\
\overline{F^n}(i) &amp; = \begin{cases}
 1, &amp; \text{если 
  $\overline{M}(x_i^n) + M(\xi_i^n) \leqslant \overline{M}(x_i^m) + M(\xi_i^m$)} \\
 0, &amp; \text{иначе}
 \end{cases}\\
M(x_0^n) &amp; = 0\\
n &amp; = \overline{1, N}
\end{aligned}
\right.$$</span><br /></p>
<p>Математическая модель оптимистического алгоритма может быть представлена в виде: <br /><span class="math display">$$\label{eq:АС с синхронизацией взаимодействий}
\left\{
\begin{aligned}
x_{i+1}^n &amp; = x_i^n + \xi_i^n-\max\limits_{m=\overline{1, N}}((x_i^n-x_i^m)I_i^{m\rightarrow n}I_i^{x_i^m&lt;x_i^n})\\
x_0^n &amp; = 0\\
n &amp; = \overline{1, N}
\end{aligned}
\right.$$</span><br /> где <span class="math inline"><em>I</em><sub><em>i</em></sub><sup><em>m</em> → <em>n</em></sup></span> — событие, означающее посылку сообщения процессом <span class="math inline"><em>m</em></span> процессу <span class="math inline"><em>n</em></span>, <span class="math inline"><em>I</em><sub><em>i</em></sub><sup><em>x</em><sub><em>i</em></sub><sup><em>m</em></sup> &lt; <em>x</em><sub><em>i</em></sub><sup><em>n</em></sup></sup></span> — событие, означающее, что время процесса <span class="math inline"><em>m</em></span> меньше времени процесса <span class="math inline"><em>n</em></span>.</p>
<p>Если обозначить <span class="math inline"><em>ρ</em><sub><em>i</em></sub><sup><em>m</em><em>n</em></sup> = (<em>x</em><sub><em>i</em></sub><sup><em>n</em></sup> − <em>x</em><sub><em>i</em></sub><sup><em>m</em></sup>)<em>I</em><sub><em>i</em></sub><sup><em>x</em><sub><em>i</em></sub><sup><em>m</em></sup> &lt; <em>x</em><sub><em>i</em></sub><sup><em>n</em></sup></sup></span>, <span class="math inline"><em>α</em><sub><em>i</em></sub><sup><em>m</em><em>n</em></sup> = <em>I</em><sub><em>i</em></sub><sup><em>m</em> → <em>n</em></sup></span> получим следующую форму записи: <br /><span class="math display">$$\label{eq:АС с синхронизацией взаимодействий}
\left\{
\begin{aligned}
x_{i+1}^n &amp; = x_i^n + \xi_i^n-\max\limits_{m=\overline{1, N}}(\alpha_i^{mn}\rho_i^{mn})\\
x_0^n &amp; = 0\\
n &amp; = \overline{1, N}
\end{aligned}
\right.$$</span><br /> С учетом оценки математических ожиданий величин <span class="math inline">{<em>x</em><sub><em>i</em></sub><sup><em>n</em></sup>}</span>, получим: <br /><span class="math display">$$\label{eq:АС с синхронизацией взаимодействий}
O^n(i)=
\left\{
\begin{aligned}
\overline{M}(x_{i+1}^n) &amp; = \overline{M}(x_i^n) + M(\xi_i^n)-\max\limits_{m=\overline{1, N}}(\alpha_i^{mn}\overline{M}(\rho_i^{mn}))\\
\overline{M}(\rho_i^{mn}) &amp; = \begin{cases}
\overline{M}(x_i^n)-\overline{M}(x_i^m), &amp; \text{если $\overline{M}(x_i^n)&gt;\overline{M}(x_i^m)$} \\
 0, &amp; \text{если $\overline{M}(x_i^n)\leqslant\overline{M}(x_i^m)$}
 \end{cases}\\
M(x_0^n) &amp; = 0\\
n &amp; = \overline{1, N}
\end{aligned}
\right.$$</span><br /></p>
<p>Оба приведенных алгоритма синхронизации обладают определенными недостатками: консервативный алгоритм допускает &lt;&lt;простои&gt;&gt; модельного времени процессов, оптимистический — &lt;&lt;откаты&gt;&gt; модельного времени.</p>
<p>Для уменьшения количества простоев и откатов модельного времени разработан алгоритм выбора оптимальной синхронизации процессов, основанный на анализе продвижения модельного времени каждым процессом.</p>
<p>Начало моделирования происходит под управлением консервативного алгоритма. Продвижение времени каждого процесса, участвующего в моделировании, оценивается на предмет изменения приращения его локального времени, а так же интенсивности посылки этим процессом сообщений другим процессам, участвующим в моделировании.</p>
<p>Согласно <span class="citation">[@voz-disser]</span> процессы можно условно разделить на три типа:</p>
<ol style="list-style-type: decimal">
<li><p>Тип 1. Математические ожидания приращений локальных часов имеют небольшой разброс , процессы активно обмениваются сообщениями . К данному типу могут быть отнесены имитационные модели сетей, многопроцессорных систем обработки сигналов и любого коммуникационного оборудования.</p></li>
<li><p>Тип 2. Математические ожидания приращений локального времени имеют неограниченный разброс, процессы довольно редко обмениваются сообщениями . Данному типу соответствуют имитационные модели работы сложных параллельных алгоритмов, где процессы в основном заняты своими внутренними вычислениями и обмениваются только входными данными и результатами. К этому типу могут относиться, например, имитационные модели алгоритмов бортового вычислительного комплекса летательного аппарата.</p></li>
<li><p>Тип 3. Разброс математических ожиданий неограничен, процессы обмениваются сообщениями с разной интенсивностью. К такому типу можно отнести полные модели распределенных вычислительных систем, например имитационная модель бортового навигационного комплекса.</p></li>
</ol>
<p>Там же, в ходе экспериментов было установлено, что в зависимости от распределения приращений локальных часов можно говорить о наибольшей эффективности какого-либо алгоритма синхронизации для определенного типа процесса.</p>
<p>В общем виде алгоритм выбора оптимальной синхронизации следующий.</p>
<ul>
<li><p>Ввод исходных данных: число процессов, участвующих в моделировании, число шагов моделирования, вероятность посылки сообщений процессами лежит в интервале от 0 до 1, разброс приращений локальных часов — неограничен.</p></li>
<li><p>Старт моделирования. На данном шаге генерируются последовательности посылки сообщений каждым процессом и приращения локального времени для процесса.</p></li>
<li><p>Процессы в соответствии с последовательностями обмениваются сообщениями. Продвижение времени происходит по консервативному алгоритму.</p></li>
<li><p>Если заключительный шаг моделирования не достигнут, то в течение (следующих) <span class="math inline">10</span> шагов анализируются интенсивности посылки сообщений каждым процессом и величины локального приращения времени. Иначе — моделирование заканчивается. Если пара &lt;&lt;<em>вероятность посылки сообщений — локальное приращение времени процесса</em>&gt;&gt; удовлетворяет какому-либо заданному типу, то следующие <span class="math inline">10</span> шагов процесс осуществляет продвижение времени, синхронизируя его с помощью наиболее оптимального для этой пары алгоритма синхронизации. Например, процесс посылает сообщения с интенсивностью 6 сообщений за 10 шагов. Это означает, что вероятность посылки составляет <span class="math inline">0.6</span>. Если приращение локального времени процесса в результате получения сообщений от других процессов , то процесс принадлежит к типу <span class="math inline">1</span>. Для данного типа процессов наиболее эффективен консервативный алгоритм синхронизации. Это означает, что следующие <span class="math inline">10</span> шагов процесс будет продвигать свое время с помощью консервативного алгоритма. Если один из параметров процесса указывает на его принадлежность к типу <span class="math inline">2</span>, то наиболее оптимальным алгоритмом синхронизации для процесса будет оптимистический и следующие <span class="math inline">10</span> шагов процесс будет продвигать свое время с помощью этого алгоритма.</p></li>
<li><p>Переход на Шаг 4.</p></li>
</ul>
<p>Обозначим <span class="math inline"><em>Θ</em><sup><em>n</em></sup>(<em>i</em>)</span> функцию, меняющую свое значение в зависимости от типа процесса</p>
<p><br /><span class="math display">$$\label{eq:АС с синхронизацией взаимодействий}
\overline\Theta^n(i)=
\left.
\begin{cases}
 1, &amp; \text{если
  $\alpha^{mn}\rightarrow 1$, \,$\Delta T \leqslant 50\%$} \\
 0, &amp; \text{если
 $\alpha^{mn} &lt; 0.5, \, \Delta T \rightarrow\infty$} \\
 &amp; \text{если
 $\alpha^{mn}\in [0\ldots1], \, \Delta T \in[0\ldots \infty]$} \\
m,\;n &amp; = \overline{1, N}
\end{cases}
\right.$$</span><br /></p>
<p>где <span class="math inline"><em>Δ</em><em>T</em></span> — относительное приращение локального времени процессом.</p>
<p><br /><span class="math display">$$\begin{aligned}
\Delta T_{\text{отн.}}= \frac{\Delta T_{\text{абс.}}}{min\,M(\xi_i^n)}100\%\,,
\\
\Delta T_{\text{абс.}}=max\,M(\xi_i^n)-min\,M(\xi_i^n)\,.
\end{aligned}$$</span><br /></p>
<p>Математическая модель выбора оптимального алгоритма синхронизации, с учетом оценок математического ожидания, будет иметь вид:</p>
<p><br /><span class="math display">$$\label{eq:АС с синхронизацией взаимодействий}
\left\{
\begin{aligned}
\overline{M}(x_{i+1}^n) &amp; = \overline{K^n}(i)\overline{\Theta^n}(i) + \overline{O^n}(i)\overline{\Theta^n}(i) \\
\overline{K_i^n}(i) &amp; = \overline{M}(x_i^n) + M(\xi_i^n) \overline{F^n}(i) \\
\overline{F^n}(i) &amp; = \begin{cases}
 1, &amp; \text{если  
 $\overline{M}(x_i^n) + M(\xi_i^n) \leqslant \overline{M}(x_i^m) + M(\xi_i^m$)} \\
 0, &amp; \text{иначе}
 \end{cases} \\
 \overline{O_i^n}(i) &amp; = \overline{M}(x_i^n) + M(\xi_i^n)-\max\limits_{m=\overline{1, N}}(\alpha_i^{mn}\overline{M}(\rho_i^{mn})) \\
\overline{M}(\rho_i^{mn}) &amp; = \begin{cases}
\overline{M}(x_i^n)-\overline{M}(x_i^m), &amp; \text{если $\overline{M}(x_i^n)&gt;\overline{M}(x_i^m)$} \\
 0, &amp; \text{если $\overline{M}(x_i^n)\leqslant\overline{M}(x_i^m)$}
 \end{cases} \\
\overline{\Theta^n}(i) &amp; = \begin{cases}
1, &amp; \text{если 
 $\alpha^{mn}\rightarrow 1, \, \Delta T \leqslant50\%$} \\
 0, &amp; \text{если
 $\alpha^{mn} &lt; 0.5, \, \Delta T \rightarrow\infty$} \\
 &amp; \text{
 $\alpha^{mn}\in [0\ldots1], \, \Delta T \in[0\ldots \infty]$} \\
m,\;n &amp; = \overline{1, N}
 \end{cases} \\
M(x_0^n) &amp; = 0 \\
m,\,n &amp; = \overline{1, N}
\end{aligned}
\right.$$</span><br /></p>
<p>Работа алгоритма была смоделирована с применением приложения Wolfram Mathematica и показала следующие результаты (на рисунке продвижение времени оптимальным алгоритмам обозначено как &lt;&lt;КАС +&gt;&gt;).</p>
<ol style="list-style-type: decimal">
<li><p>Все процессы принадлежат 1 типу.</p>
<div class="figure">
<img src="графика/typeA.png" alt="Тип 1. Продвижение времени алгоритмами синхронизации" />
<p class="caption">Тип 1. Продвижение времени алгоритмами синхронизации</p>
</div>
<div class="figure">
<img src="графика/tableA.png" alt="Тип 1. Сравнительная эффективность алгоритмов синхронизации" />
<p class="caption">Тип 1. Сравнительная эффективность алгоритмов синхронизации</p>
</div></li>
<li><p>Все процессы принадлежат 2 типу.</p>
<div class="figure">
<img src="графика/typeB.png" alt="Тип 2. Продвижение времени алгоритмами синхронизации" />
<p class="caption">Тип 2. Продвижение времени алгоритмами синхронизации</p>
</div>
<div class="figure">
<img src="графика/tableB.png" alt="Тип 2. Сравнительная эффективность алгоритмов синхронизации" />
<p class="caption">Тип 2. Сравнительная эффективность алгоритмов синхронизации</p>
</div></li>
<li><p>Процессы смешанного типа.</p>
<div class="figure">
<img src="графика/typeAB.png" alt="Тип 3. Продвижение времени алгоритмами синхронизации" />
<p class="caption">Тип 3. Продвижение времени алгоритмами синхронизации</p>
</div>
<div class="figure">
<img src="графика/tableAB.png" alt="Тип 3. Сравнительная эффективность алгоритмов синхронизации" />
<p class="caption">Тип 3. Сравнительная эффективность алгоритмов синхронизации</p>
</div></li>
</ol>
<p>Выводы.</p>
<p>Эксперименты показали, что продвижение времени процессами с помощью алгоритма выбора оптимальной синхронизации для всех типов процессов дает лучший результат, чем в случае, если бы продвижение времени происходило с помощью только консервативного алгоритма или только оптимистического алгоритма синхронизации. В случае, когда синхронизация времени осуществляется для процессов типа 1, алгоритм выбора оптимальной синхронизации дает результаты едва лучшие алгоритма оптимистического. В случае, когда продвижение времени процессов осуществляется для процессов типа 2, алгоритм выбора оптимальной синхронизации показывает результаты лучшие, чем консервативный и значительно лучшие, чем оптимистический. При использовании смешанного типа процессов, алгоритм выбора оптимальной синхронизации так же способен показывать результаты, лучшие, чем алгоритмы консервативной и оптимистической синхронизации.</p>
