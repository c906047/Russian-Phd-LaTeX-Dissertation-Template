\input{../hx}
\input{../tikzset}


\begin{document}

%\section{Математические модели взаимодействия приложения с алгоритмами синхронизации}
%
%\subsection{Взаимодействие приложения со строго синхронным АС}
%
%\begin{equation}
%\label{eq:АС с синхронизацией взаимодействий}
%\left\{
%\begin{aligned}
%x_{i+1}^n & = \begin{cases}
% x_{i}^n = x_i^n + \xi_i^n, & \text{если $x_i^n=X_i$} \\
% x_{i}^n, & \text{иначе}
% \end{cases}\\
%X_{i+1}^n & = \min\limits_{n=\overline{1,N}}(x_{i+1}^n)\\
%x_{0}^n&=0\\
%X_{0}^n&=0\\
%n & = \overline{1, N}
%\end{aligned}
%\right.
%\end{equation}
%
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.65]{графика/1.1.png}
%
%\caption{Продвижение времени}
%\label{fig:выполнение модели}
%\end{figure}
%
%
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.7]{графика/1.2.png}
%
%\caption{Продвижение времени}
%\label{fig:выполнение модели}
%\end{figure}
%
%\subsection{Взаимодействие приложения с консервативным АС}
%
%\begin{equation}
%\label{eq:АС с синхронизацией взаимодействий}
%\left\{
%\begin{aligned}
%x_{i+1}^n & = x_i^n + \xi_i^n F^n(i)\\
%F^n(i) & = \begin{cases}
% 1, & \text{если $\forall m \in M^n : x_i^n + \xi_i^n \leqslant x_i^m + \xi_i^m$} \\
% 0, & \text{иначе}
% \end{cases}\\
%x_0^n & = 0\\
%n & = \overline{1, N}
%\end{aligned}
%\right.
%\end{equation}
%
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.65]{графика/2.1.png}
%
%\caption{Продвижение времени}
%\label{fig:выполнение модели}
%\end{figure}
%
%
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.65]{графика/2.2.png}
%
%\caption{Продвижение времени}
%\label{fig:выполнение модели}
%\end{figure}
%
%
%\subsection{Взаимодействие приложения с оптимистическим АС}
%
%\begin{equation}
%\label{eq:АС с синхронизацией взаимодействий}
%\left\{
%\begin{aligned}
%x_{i+1}^n & = x_i^n + \xi_i^n-\max\limits_{m=\overline{1, N}}((x_i^n-x_i^m)I_i^{m\rightarrow n}I_i^{x_i^m<x_i^n})\\
%x_0^n & = 0\\
%n & = \overline{1, N}
%\end{aligned}
%\right.
%\end{equation}
%
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.65]{графика/3.1.png}
%
%\caption{Продвижение времени}
%\label{fig:выполнение модели}
%\end{figure}
%
%
%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.65]{графика/3.2.png}
%
%\caption{Продвижение времени}
%\label{fig:выполнение модели}
%\end{figure}
%
%Вывод:
%Согласно выдвинутого ранее критерия эффективности АС, лучшим для данного приложения (модели) является тот АС, который быстрее других продвигает её модельное время.
%
%В результате проведенных экспериментов с моделями взаимодействия исследуемого приложения с алгоритмами синхронизации, можно сделать вывод, что лучшим среди исследованных строго синхронного, консервативного и оптимистического АС является последний, т.к. продвигает модельное время на большую, чем остальные АС величину.
\likechapter{Алгоритм выбора оптимальной синхронизации процессов в распределенной имитационной системе}

Благодаря интенсивному развитию вычислительной техники моделирование приобретает общенаучный характер и применяется в исследованиях объектов и процессов, происходящих в природе, в науках о человеке и обществе.

Одним из наиболее важных применений моделей в практическом, и в историческом аспектах является прогнозирование поведения моделируемых объектов.

Моделирование применяется сегодня в самых различных областях: экологии и геофизике (анализ распространения загрязняющих веществ в атмосфере), транспорте (конструирование транспортных средств, полетные имитаторы для тренировки пилотов), электронике и электротехнике (эмуляция работы электронных устройств), экономике и финансах (прогнозирование цен на финансовых рынках), архитектуре и строительстве (исследование поведения зданий, конструкций и деталей под механической нагрузкой), управлении и бизнесе (моделирование рынков сбыта и рынков сырья), промышленности (моделирование роботов и автоматических манипуляторов), медицине и биологии (моделирование пандемий и эпидемий), политике и военном деле (моделирование развития межгосударственных отношений, моделирование театра военных действий).


Применение моделей позволяет проводить контролируемые эксперименты в тех ситуациях, где экспериментирование на реальных объектах было бы практически невозможным или экономически нецелесообразным.~\cite{Shennon} В таких случаях может быть построена модель, на которой необходимые эксперименты могут быть проведены с относительной легкостью и недорого.

%Непосредственное экспериментирование с системой обычно состоит в варьировании её некоторых параметров. При этом, поддерживая все остальные параметры неизменными, наблюдают результаты эксперимента.  

%Зачастую моделирование используется в тех случаях, когда исследование процесса невозможно или невыгодно по определенным причинам, например, это может быть высокая стоимость создания процесса, его сложное строение, небольшие пространственно-временные размеры и т.д.

Выделяют три основных вида моделирования: аналитическое, численное и имитационное \cite{disksobmod}. В данной работе речь пойдет о имитационном моделировании. Имитационное моделирование --- моделирование, при котором моделирующий алгоритм с той или иной степень точности воспроизводит функционирование исходной системы. Имитационная модель воспроизводит поведение моделируемой системы во времени. Имитационная модель может быть выполнена на распределенной вычислительной системе, где выигрыш по времени выполнения модели достигается за счет параллельного выполнения событий, запланированных на разные моменты модельного времени.

Существует несколько технологий на уровне архитектур, которые позволяют задать основные правила создания распределенных имитационных моделей: DDS, ARIS, HLA и др.

HLA (High-level architecture) --- архитектура высокого уровня, представляет собой архитектуру общего назначения для распределенных компьютерных имитационных систем. Является стандартом IEEE~1516.
В соответствии с правилами построения имитационных моделей по архитектуре HLA были реализованы, например, такие проекты как объединение центров управления космическими аппаратами в рамках программы МКС в единую распределенную систему (РКК Энергия/Королев --- ATVCC/Тулуза --- NASA JSC/Хьюстон); предшественник HLA --- сеть SIMNET реально использовалась для тренировок и поддержки военных операций (а также их последующего анализа), например, в 1992 году в рамках кампании <<Буря в пустыне>>; 333-й Центр боевой подготовки сухопутных войск в п.\,Мулино и др.

В имитационном моделировании принято различать три понятия времени: физическое, модельное, процессорное \cite{okol}. Сущностью имитационного моделирования является продвижение модельного времени при выполнении модели и выполнение событий, связанных с определенными значениями модельного времени. В распределенной модели первичной единицей является логический процесс. Каждый логический процесс выполняется в своем модельном времени как самостоятельная последовательная модель. Логический процесс взаимодействует с другими процессами, передавая им сообщения. При распределенной реализации модельное время в разных логических процессах движется с разными скоростями и в некоторый произвольный момент времени оказывается разным.

Проиллюстрируем сказанное на примере исторического события --- битвы при Ватерлоо.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{графика/waterloo.pdf}
\caption{Корректная временная диаграмма исполнения модели}
%\label{fig:выполнение модели}
\end{figure}

Наполеон Бонапарт (процесс $N$) должен был вступить в бой с герцогом Веллингтоном (процесс $W$), расположившемся со своей английской армией на пути к Брюсселю. Но оба полководца ждали подкрепления: герцог Веллингтон --- прусского князя Блюхера (процесс $B$), Наполеон --- своего маршала Груш\'и (процесс $G$). И Наполеон и Веллингтон отправили командующим своими подкреплениями сообщения с категорическим требованием скорейшего прибытия под Ватерлоо для усиления основной группировки войск. Тем временем, армия Бонапарта в ожидании прибытия подкрепления маршала Груши начала атаку неприятеля. Веллингтону ничего не оставалось, как принять бой. Не смотря на более выгодное расположение войск Веллингтона и примерно равные силы с Наполеоном, французы развивали успешное наступление на англичан и едва не опрокинули их --- положение Веллингтона становилось критическим. И только вовремя подоспевшее подкрепление князя Блюхера помогло герцогу сдержать натиск Наполеона, а затем и перейти в контрнаступление на французов. После чего, так и не дождавшийся своего маршала с подкреплением, французский император был разбит.

Предположим, что эти процессы выполняются на распределенной системе. И процесс $B$ в силу определенных причин (например, резко возросла нагрузка на процессор) выполняется медленнее. Следовательно возникли задержки. Для логического процесса $W$ получение сообщения в момент времени $t5$ означает изменение прошлого в момент времени $t4$, что нарушает корректную последовательность развития моделирования.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{графика/unwaterloo.pdf}
\caption{Некорректная временная диаграмма исполнения модели}
%\label{fig:выполнение модели}
\end{figure}

Для того, чтобы модель правильно воспроизводила последовательность событий в моделируемой системе, необходимо чтобы не возникало подобных парадоксов времени.
Тот процесс продвигает свое время вперед, который получил сообщение от процесса с б\'ольшим временем. Если процесс получает сообщение от процесса с меньшим временем, т.е. $t_i^m<t_i^n, \, m \to n$, получаем парадокс, т.е. говорят, что процесс приславший сообщение \elki{из прошлого} отстает во времени~\cite{okol}.

Для того, чтобы парадоксов времени в системе не возникало, необходимо предусмотреть специальные программы, которые бы синхронизировали по времени процессы в моделируемой системе. Такие программы получили название алгоритмов синхронизации модельного времени. Алгоритмы синхронизации разнообразны, но все их как правило можно разделить на два основных класса: консервативные и оптимистические.

Если синхронизация модельного времени процессов происходит под управлением консервативного алгоритма, это предполагает, что процесс получает сообщения в том же порядке, в котором их посылает ему отправитель.
Иначе, консервативные алгоритмы блокируют продвижение модельного времени в том случае, если процесс получил сообщение от процесса с меньшим временем.

Оптимистические алгоритмы в аналогичном случае осуществляют откат времени процесса с большим временем до времени процесса, приславшего сообщение, обрабатывает его, а так же заново обрабатывают все сообщения от этого времени до текущего в правильной временной последовательности.


Математически модель консервативного алгоритма синхронизации может быть представлена в виде \cite{voz-disser}:
\begin{equation}
\label{eq:АС с синхронизацией взаимодействий}
\left\{
\begin{aligned}
x_{i+1}^n & = x_i^n + \xi_i^n F^n(i)\\
F^n(i) & = \begin{cases}
 1, & \text{если $\forall m \in M^n : x_i^n + \xi_i^n \leqslant x_i^m + \xi_i^m$} \\
 0, & \text{иначе}
 \end{cases}\\
x_0^n & = 0\\
n & = \overline{1, N}
\end{aligned}
\right.
\end{equation}
где $x_{i+1}^n$ --- время процесса $n$ на следующем шаге, $\xi_i^n$ --- локальное приращение времени процесса $n$ (время, затрачиваемое процессом на внутреннюю работу), $n$ --- процесс, который продвигает время (получает сообщение от процесса $m$), $m$ --- процесс, посылающий сообщение процессу $n$.
Поскольку общее модельное время $T_I$ --- случайная величина, будем искать ее математическое ожидание, т.е. модельное время всей системы на $i$-ом шаге равно минимальному времени процесса на этом шаге: $\forall\,i: M(T_i)=M(x_i)$.
\todo{Доказать оценку матожидания}
С учетом оценки математических ожиданий величин $\{x_i^{n}\}$, получаем:
\begin{equation}
\label{eq:АС с синхронизацией взаимодействий}
K^n(i)=
\left\{
\begin{aligned}
\overline{M}(x_{i+1}^n) & = \overline{M}(x_i^n) + M(\xi_i^n) \overline{F^n}(i)\\
\overline{F^n}(i) & = \begin{cases}
 1, & \text{если 
 %$\forall m \in M^n : 
 $\overline{M}(x_i^n) + M(\xi_i^n) \leqslant \overline{M}(x_i^m) + M(\xi_i^m$)} \\
 0, & \text{иначе}
 \end{cases}\\
M(x_0^n) & = 0\\
n & = \overline{1, N}
\end{aligned}
\right.
\end{equation}
  
Математически модель оптимистического алгоритма может быть представлена в виде:
\begin{equation}
\label{eq:АС с синхронизацией взаимодействий}
\left\{
\begin{aligned}
x_{i+1}^n & = x_i^n + \xi_i^n-\max\limits_{m=\overline{1, N}}((x_i^n-x_i^m)I_i^{m\rightarrow n}I_i^{x_i^m<x_i^n})\\
x_0^n & = 0\\
n & = \overline{1, N}
\end{aligned}
\right.
\end{equation}
где $I_i^{m\rightarrow n}$ --- событие, означающее посылку сообщения процессом $m$ процессу $n$, $I_i^{x_i^m<x_i^n}$ --- событие, означающее, что время процесса $m$ меньше времени процесса $n$.

Если обозначить $\rho_i^{mn}=(x_i^n-x_i^m)I_i^{x_i^m<x_i^n}$, $\alpha_i^{mn}=I_i^{m\rightarrow n}$ получим следующую форму записи:
\begin{equation}
\label{eq:АС с синхронизацией взаимодействий}
\left\{
\begin{aligned}
x_{i+1}^n & = x_i^n + \xi_i^n-\max\limits_{m=\overline{1, N}}(\alpha_i^{mn}\rho_i^{mn})\\
x_0^n & = 0\\
n & = \overline{1, N}
\end{aligned}
\right.
\end{equation}
С учетом оценки математических ожиданий величин $\{x_i^{n}\}$, получим:
\begin{equation}
\label{eq:АС с синхронизацией взаимодействий}
O^n(i)=
\left\{
\begin{aligned}
\overline{M}(x_{i+1}^n) & = \overline{M}(x_i^n) + M(\xi_i^n)-\max\limits_{m=\overline{1, N}}(\alpha_i^{mn}\overline{M}(\rho_i^{mn}))\\
\overline{M}(\rho_i^{mn}) & = \begin{cases}
\overline{M}(x_i^n)-\overline{M}(x_i^m), & \text{если $\overline{M}(x_i^n)>\overline{M}(x_i^m)$} \\
 0, & \text{если $\overline{M}(x_i^n)\leqslant\overline{M}(x_i^m)$}
 \end{cases}\\
M(x_0^n) & = 0\\
n & = \overline{1, N}
\end{aligned}
\right.
\end{equation}

Оба алгоритма синхронизации обладают определенными недостатками: консервативный алгоритм допускает "простои" модельного времени процессов, оптимистический --- "откаты" модельного времени.

Для уменьшения количества простоев и откатов модельного времени предлагается алгоритм выбора оптимальной синхронизации процессов, основанный на анализе продвижения модельного времени каждым процессом.

Начало моделирования происходит под управлением консервативного алгоритма. Продвижение времени каждого процесса, участвующего в моделировании, оценивается на предмет изменения приращения его локального времени, а так же интенсивности посылки этим процессом сообщений другим процессам, участвующим в моделировании.

Согласно \cite{voz-disser} процессы можно условно разделить на три типа: 
\begin{enumerate}
  \item Тип 1. Математические ожидания приращений локальных часов имеют небольшой разброс $\leqslant 50\%$, процессы активно обмениваются сообщениями $\alpha^{mn}\rightarrow 1$. К данному типу могут быть отнесены имитационные модели сетей, многопроцессорных систем обработки сигналов и любого коммуникационного оборудования.
  \item Тип 2. Математические ожидания приращений локального времени имеют неограниченный разброс, процессы довольно редко обмениваются сообщениями $\alpha^{mn}<0.5$. Данному типу соответствуют имитационные модели работы сложных параллельных алгоритмов, где процессы в основном заняты своими внутренними вычислениями и обмениваются только входными данными и результатами. К этому типу могут относиться, например, имитационные модели алгоритмов бортового вычислительного комплекса летательного аппарата.
  \item Тип 3. Разброс математических ожиданий неограничен, процессы обмениваются сообщениями с разной интенсивностью. К такому типу можно отнести полные модели распределенных вычислительных систем, например имитационная модель бортового навигационного комплекса.
\end{enumerate}

Там же, в ходе экспериментов было установлено, что в зависимости от распределения приращений локальных часов можно говорить о наибольшей эффективности какого-либо алгоритма синхронизации для определенного типа процесса.

В общем виде алгоритм выбора оптимальной синхронизации следующий.
\begin{itemize}


\item[Шаг 1.] Ввод исходных данных: число процессов, участвующих в моделировании, число шагов моделирования, вероятность посылки сообщений процессами лежит в интервале от 0 до 1, разброс приращений локальных часов --- неограничен.

\item[Шаг 2.] Старт моделирования. На данном шаге генерируются последовательности посылки сообщений каждым процессом и приращения локального времени для процесса. 

\item[Шаг\;3.] Процессы в соответствии с последовательностями обмениваются сообщениями. Продвижение времени происходит по консервативному алгоритму.

\item[Шаг\;4.] Если заключительный шаг моделирования не достигнут, то в течение (следующих) 10 шагов анализируются интенсивности посылки сообщений каждым процессом и величины локального приращения времени. Иначе --- моделирование заканчивается. Если пара "вероятность посылки сообщений --- локальное приращение времени процесса" удовлетворяет какому-либо заданному типу, то следующие 10 шагов процесс осуществляет продвижение времени, синхронизируя его с помощью наиболее оптимального для этой пары алгоритма синхронизации. Например, процесс посылает сообщения с интенсивностью 6 сообщений за 10 шагов. Это означает, что вероятность посылки составляет $0.6$. Если приращение локального времени процесса в результате получения сообщений от других процессов $\leqslant 50\%$, то процесс принадлежит к типу 1. Для данного типа процессов наиболее эффективен консервативный алгоритм синхронизации. Это означает, что следующие 10 шагов процесс будет продвигать свое время с помощью консервативного алгоритма. Если один из параметров процесса указывает на его принадлежность к типу 2, то наиболее оптимальным алгоритмом синхронизации для процесса будет оптимистический и следующие 10 шагов процесс будет продвигать свое время с помощью этого алгоритма.

\item[Шаг 5.] Переход на Шаг 4.

\end{itemize}

Обозначим $\Theta^n(i)$ функцию, меняющую свое значение в зависимости от типа процесса

\begin{equation}
\label{eq:АС с синхронизацией взаимодействий}
\overline\Theta^n(i)=
\left.
\begin{cases}
 1, & \text{если
 %$\forall m \in M^n : 
 $\alpha^{mn}\rightarrow 1; \; \Delta T \leqslant50\%$} \\
 0, & \text{если
 $\alpha^{mn} < 0.5; \; \Delta T \rightarrow\infty$;} \\
  & \text{если
 $\alpha^{mn}\in [0\ldots1] ;\; \Delta T \in[0\ldots \infty]$} \\
m,\;n & = \overline{1, N}
\end{cases}
\right.
\end{equation}

где $\Delta T$ --- относительное приращение локального времени процессом.

\begin{equation}
\begin{aligned}
\Delta T_{\text{отн.}}= \frac{\Delta T_{\text{абс.}}}{min\,M(\xi_i^n)}100\%\,,
\\
\Delta T_{\text{абс.}}=max\,M(\xi_i^n)-min\,M(\xi_i^n)
\end{aligned}
\end{equation}

Математическая модель выбора оптимального алгоритма синхронизации, с учетом оценок математического ожидания, будет иметь вид:

%%% Здесь посмотреть на диссер харьковчан, как там записывается полная матмодель
%%% Разобраться с оверлайн над функциями

\begin{equation}
\label{eq:АС с синхронизацией взаимодействий}
\left\{
\begin{aligned}
\overline{M}(x_{i+1}^n) & = \overline{K^n}(i)\overline{\Theta^n}(i) + \overline{O^n}(i)\overline{\Theta^n}(i)\\
\overline{K_i^n}(i) & = \overline{M}(x_i^n) + M(\xi_i^n) \overline{F^n}(i)\\
\overline{F^n}(i) & = \begin{cases}
 1, & \text{если 
 %$\forall m \in M^n : 
 $\overline{M}(x_i^n) + M(\xi_i^n) \leqslant \overline{M}(x_i^m) + M(\xi_i^m$)} \\
 0, & \text{иначе}
 \end{cases}\\
 \overline{O_i^n}(i) & = \overline{M}(x_i^n) + M(\xi_i^n)-\max\limits_{m=\overline{1, N}}(\alpha_i^{mn}\overline{M}(\rho_i^{mn}))\\
\overline{M}(\rho_i^{mn}) & = \begin{cases}
\overline{M}(x_i^n)-\overline{M}(x_i^m), & \text{если $\overline{M}(x_i^n)>\overline{M}(x_i^m)$} \\
 0, & \text{если $\overline{M}(x_i^n)\leqslant\overline{M}(x_i^m)$}
 \end{cases}\\
\overline{\Theta^n}(i) & = \begin{cases}
1, & \text{если
 %$\forall m \in M^n : 
 $\alpha^{mn}\rightarrow 1; \; \Delta T \leqslant50\%$} \\
 0, & \text{если
 $\alpha^{mn} < 0.5; \; \Delta T \rightarrow\infty$;} \\
  & \text{
 $\alpha^{mn}\in [0\ldots1] ;\; \Delta T \in[0\ldots \infty]$} \\
m,\;n & = \overline{1, N}
 \end{cases}\\
M(x_0^n) & = 0\\
m,n & = \overline{1, N}
\end{aligned}
\right.
\end{equation}

Моделирование продвижения времени имитационной моделью с помощью данного алгоритма показывает, что эффективность данного алгоритма возрастает с увеличением числа процессов в моделируемой системе. В этом случае в ряде экспериментов алгоритм показывает результаты даже лучшие, чем оптимистический и почти всегда лучше, чем консервативный.
На рисунке оптимальный алгоритм обозначен как "КАС +".

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{графика/test.pdf}
\caption{Продвижение времени алгоритмами синхронизации}
%\label{fig:выполнение модели}
\end{figure}

\bibliography{../nir}






%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.95]{}
%\caption{}
%\label{fig:выполнение модели}
%\end{figure}



\end{document}
